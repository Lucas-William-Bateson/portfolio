name: Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: localhost:5001

jobs:
  deploy:
    runs-on: [self-hosted]
    steps:
      - uses: actions/checkout@v4

      - name: Load Environment Variables
        run: |
          REPO_NAME="${{ github.repository }}"
          UNIQUE_APP_NAME=$(echo "${REPO_NAME##*/}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
          echo "UNIQUE_APP_NAME=$UNIQUE_APP_NAME" >> $GITHUB_ENV
          if [ -f .env.production ]; then
            set -a
            source .env.production
            set +a
            if [ -z "$APP_NAME" ] || [ "$APP_NAME" = "template" ] || [ "$APP_NAME" = "myapp" ]; then
              APP_NAME="$UNIQUE_APP_NAME"
            fi
            echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
            echo "APP_PORT=$APP_PORT" >> $GITHUB_ENV
            echo "HOST_PORT=$HOST_PORT" >> $GITHUB_ENV
            echo "CPU_LIMIT=$CPU_LIMIT" >> $GITHUB_ENV
            echo "MEMORY_LIMIT=$MEMORY_LIMIT" >> $GITHUB_ENV
            echo "MIN_CPU_LIMIT=${MIN_CPU_LIMIT:-0.25}" >> $GITHUB_ENV
            echo "MIN_MEMORY_LIMIT=${MIN_MEMORY_LIMIT:-256M}" >> $GITHUB_ENV
            echo "VERSION=${VERSION:-1.0.0}" >> $GITHUB_ENV
            echo "MAINTAINER_EMAIL=${MAINTAINER_EMAIL:-your-email@example.com}" >> $GITHUB_ENV
            echo "ENVIRONMENT=${ENVIRONMENT:-production}" >> $GITHUB_ENV
            echo "üè∑Ô∏è Using APP_NAME: $APP_NAME for deployment isolation"
          else
            echo "Error: .env.production not found and no environment variables set"
            echo "Please ensure .env.production exists or set required environment variables"
            exit 1
          fi

      - name: Build & Push
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            IMAGE_TAG="daily-$(date +'%Y%m%d')"
          else
            IMAGE_TAG="${{ github.sha }}"
          fi
          docker build \
            -f docker/Dockerfile \
            -t $REGISTRY/$APP_NAME:$IMAGE_TAG \
            -t $REGISTRY/$APP_NAME:latest \
            --label "project=$APP_NAME" \
            --label "version=$IMAGE_TAG" \
            --label "environment=production" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "commit-sha=${{ github.sha }}" \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --cache-from $REGISTRY/$APP_NAME:latest \
            .
          docker push $REGISTRY/$APP_NAME:$IMAGE_TAG
          docker push $REGISTRY/$APP_NAME:latest
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy
        run: |
          cd docker
          export IMAGE_TAG=$IMAGE_TAG
          export IMAGE_FULL="$REGISTRY/$APP_NAME:$IMAGE_TAG"
          export CONTAINER_NAME="$APP_NAME-prod"
          export NETWORK_NAME="$APP_NAME-prod-network"
          export APP_NAME=$APP_NAME
          export APP_PORT=$APP_PORT
          export HOST_PORT=$HOST_PORT
          export CPU_LIMIT=$CPU_LIMIT
          export MEMORY_LIMIT=$MEMORY_LIMIT
          export MIN_CPU_LIMIT=$MIN_CPU_LIMIT
          export MIN_MEMORY_LIMIT=$MIN_MEMORY_LIMIT
          export VERSION=$VERSION
          export MAINTAINER_EMAIL=$MAINTAINER_EMAIL
          export ENVIRONMENT=$ENVIRONMENT
          echo "IMAGE_FULL=$IMAGE_FULL" >> $GITHUB_ENV
          echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV
          echo "NETWORK_NAME=$NETWORK_NAME" >> $GITHUB_ENV
          echo "Environment variables for docker-compose:"
          echo "APP_NAME=$APP_NAME (unique per repository)"
          echo "IMAGE_FULL=$IMAGE_FULL"
          echo "CONTAINER_NAME=$CONTAINER_NAME"
          echo "NETWORK_NAME=$NETWORK_NAME"
          echo "HOST_PORT=$HOST_PORT"
          echo "APP_PORT=$APP_PORT"
          echo "üîç Checking for port conflicts..."
          EXISTING_CONTAINER=$(docker ps --filter "publish=$HOST_PORT" --format "{{.Names}}" | head -1)
          if [ ! -z "$EXISTING_CONTAINER" ]; then
            if [ "$EXISTING_CONTAINER" != "$CONTAINER_NAME" ]; then
              echo "‚ùå Port $HOST_PORT is already in use by container: $EXISTING_CONTAINER"
              echo "This indicates a port conflict between different applications."
              echo "Please check your HOST_PORT setting in .env.production"
              echo "Current deployment uses: $CONTAINER_NAME"
              echo "Conflicting container: $EXISTING_CONTAINER"
              exit 1
            else
              echo "‚úÖ Port $HOST_PORT is used by our own container: $EXISTING_CONTAINER"
              echo "Stopping our own container for update..."
              docker stop "$EXISTING_CONTAINER" || true
              docker rm "$EXISTING_CONTAINER" || true
            fi
          else
            echo "‚úÖ Port $HOST_PORT is available"
          fi
          docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml down --timeout 30 || true
          docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml up -d
          echo "Waiting for service to be ready..."
          sleep 15
          RETRY_COUNT=0
          MAX_RETRIES=5
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml ps --services --filter "status=running" | grep -q "app"; then
              echo "‚úÖ Deployment successful"
              docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml ps
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚è≥ Attempt $RETRY_COUNT/$MAX_RETRIES - Service not ready yet, waiting..."
              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "‚ùå Deployment failed - service not ready after $MAX_RETRIES attempts"
                docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml logs
                docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml ps
                exit 1
              fi
              sleep 10
            fi
          done

      - name: Health Check
        run: |
          echo "Performing health check..."
          echo "Checking service at http://localhost:$HOST_PORT"
          HEALTH_RETRY=0
          MAX_HEALTH_RETRIES=10
          while [ $HEALTH_RETRY -lt $MAX_HEALTH_RETRIES ]; do
            if curl -f -s http://localhost:$HOST_PORT/health >/dev/null 2>&1; then
              echo "‚úÖ Health check passed - /health endpoint responding"
              break
            elif curl -f -s http://localhost:$HOST_PORT >/dev/null 2>&1; then
              echo "‚úÖ Health check passed - root endpoint responding"
              break
            elif curl -s http://localhost:$HOST_PORT >/dev/null 2>&1; then
              echo "‚úÖ Health check passed - service is responding"
              break
            else
              HEALTH_RETRY=$((HEALTH_RETRY + 1))
              echo "‚è≥ Health check attempt $HEALTH_RETRY/$MAX_HEALTH_RETRIES..."
              if [ $HEALTH_RETRY -eq $MAX_HEALTH_RETRIES ]; then
                echo "‚ö†Ô∏è Health check failed after $MAX_HEALTH_RETRIES attempts"
                echo "Container status:"
                cd docker && \
                  IMAGE_FULL="$REGISTRY/$APP_NAME:$IMAGE_TAG" \
                  CONTAINER_NAME="$APP_NAME-prod" \
                  NETWORK_NAME="$APP_NAME-prod-network" \
                  APP_NAME=$APP_NAME \
                  APP_PORT=$APP_PORT \
                  HOST_PORT=$HOST_PORT \
                  CPU_LIMIT=$CPU_LIMIT \
                  MEMORY_LIMIT=$MEMORY_LIMIT \
                  MIN_CPU_LIMIT=$MIN_CPU_LIMIT \
                  MIN_MEMORY_LIMIT=$MIN_MEMORY_LIMIT \
                  VERSION=$VERSION \
                  MAINTAINER_EMAIL=$MAINTAINER_EMAIL \
                  ENVIRONMENT=$ENVIRONMENT \
                  docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml ps
                echo "Container logs (last 20 lines):"
                cd docker && \
                  IMAGE_FULL="$REGISTRY/$APP_NAME:$IMAGE_TAG" \
                  CONTAINER_NAME="$APP_NAME-prod" \
                  NETWORK_NAME="$APP_NAME-prod-network" \
                  APP_NAME=$APP_NAME \
                  APP_PORT=$APP_PORT \
                  HOST_PORT=$HOST_PORT \
                  CPU_LIMIT=$CPU_LIMIT \
                  MEMORY_LIMIT=$MEMORY_LIMIT \
                  MIN_CPU_LIMIT=$MIN_CPU_LIMIT \
                  MIN_MEMORY_LIMIT=$MIN_MEMORY_LIMIT \
                  VERSION=$VERSION \
                  MAINTAINER_EMAIL=$MAINTAINER_EMAIL \
                  ENVIRONMENT=$ENVIRONMENT \
                  docker compose -p "$APP_NAME" -f docker-compose.yml -f docker-compose.prod.yml logs --tail=20
                break
              fi
              sleep 5
            fi
          done

      - name: Cleanup
        run: |
          echo "Cleaning up old images..."
          docker images $REGISTRY/$APP_NAME --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedAt}}" | head -n 10
          OLD_IMAGES=$(docker images $REGISTRY/$APP_NAME --format "{{.ID}}" | tail -n +6)
          if [ ! -z "$OLD_IMAGES" ]; then
            echo "Removing old images: $OLD_IMAGES"
            echo "$OLD_IMAGES" | xargs -r docker rmi -f || true
          else
            echo "No old images to remove"
          fi
          docker image prune -f --filter "label=project=$APP_NAME" || true
          docker network prune -f || true
          echo "Cleanup completed"
